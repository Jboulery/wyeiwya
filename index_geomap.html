<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <style>

    body {
      background-color: white;
    }
    svg {
      border: 2px solid black;
      background-color: white;
    }

    .selected {
      fill: red;
    }

    .boundary {
      fill: #DEB887;
      stroke: black;
      stroke-width: 1px; 
    }

    .hidden {
      display: none;
    }

    div.tooltip {
      color: #222; 
      background: #fff; 
      border-radius: 3px; 
      box-shadow: 0px 0px 2px 0px #a6a6a6; 
      padding: .2em; 
      text-shadow: #f5f5f5 0 1px 0;
      opacity: 0.9; 
      position: absolute;
    }
  </style>

</head>

<body>
<div id="map"></div>
  <script src=d3/d3.min.js></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <script src="scripts/dataProcessing.js"></script>
  <script src="scripts/d3CheckBox.js"></script>
  <script src="scripts/Ranking.js"></script>
  <script>


  	d3.csv("data/food_data.csv", function(error,data) {
	// Test
	if (error){console.log(error)}
	
	else{
			// Save data

		var dataset = data;
		ByCountry = dataProcessing(data)

	    var width = 962,
	        rotated = 90,
	        height = 502;

	    //track where mouse was clicked
	    var initX;
	    //track scale only rotate when s === 1
	    var s = 1;
	    var mouseClicked = false;

	    var criteria = 0;


	    var projection = d3.geoMercator()
	        .scale(153)
	        .translate([width/2,height/1.5])
	        .rotate([rotated,0,0]); 


	    var zoom = d3.zoom()
	         .scaleExtent([1, 20])
	         .on("zoom", zoomed);

	    var svg = d3.select("body").append("svg")
	    .attr("width", width)
	    .attr("height", height)
	    //track where user clicked down
	    .on("mousedown", function() {
	             d3.event.preventDefault(); 
	             //only if scale === 1
	             if(s !== 1) return;
	               initX = d3.mouse(this)[0];
	               mouseClicked = true;
	          })
	    .on("mouseup", function() {
	              if(s !== 1) return;
	              rotated = rotated + ((d3.mouse(this)[0] - initX) * 360 / (s * width));
	              mouseClicked = false;
	          })
	    .call(zoom);


	      function rotateMap(endX) {
	        projection.rotate([rotated + (endX - initX) * 360 / (s * width),0,0])
	            g.selectAll('path')       // re-project path data
	           .attr('d', path);
	      }
	    //for tooltip 
	    var offsetL = document.getElementById('map').offsetLeft+10;
	    var offsetT = document.getElementById('map').offsetTop+10;

	    var path = d3.geoPath()
	        .projection(projection);

	    var tooltip = d3.select("#map")
	         .append("div")
	         .attr("class", "tooltip hidden");

	    //need this for correct panning
	    var g = svg.append("g");

	    var colorMin = d3.min(ByCountry, function(d) { return d.means[criteria]; } );
	    var colorMax = d3.max(ByCountry, function(d) { return d.means[criteria]; } );

	    var color = d3.scaleLinear()
	    .domain([colorMin, colorMax])
	    .range([d3.rgb(50,0,0),d3.rgb(200,0,0)])

	    //det json data and draw it
	    d3.json("data/world.json", function(error, world) {
	      if(error) return console.error(error);

	      //countries
	      g.append("g")
	          .attr("class", "boundary")
	        .selectAll("boundary")
	          .data(topojson.feature(world, world.objects.countries).features)
	          .enter().append("path")
	          .attr("name", function(d) {return d.properties.name;})
	          .attr("id", function(d) { return d.id;})
	          .style("fill",function(geomap){
	          	var coloring;
	          	ByCountry.forEach(function(country){
	          		if (country.key == geomap.properties.name){
	          			coloring = color(country.means[criteria]);
	          		}
	          	});
	          	return coloring;
	          })
	          .on('click', selected)
	          .on("mousemove", showTooltip)
	          .on("mouseout",  function(d,i) {
	              tooltip.classed("hidden", true);
	           })
	          .attr("d", path);
	    });


	    	// Sort countries according to "criteria"
		 var max=ByCountry
			.sort(function(a,b){return b.means[criteria]-a.means[criteria];})
			.map(function(d){return d.key;});

	    function showTooltip(d) {
	      name = d.properties.name;
	      var value;
	      var rank = max.indexOf(d.properties.name);
	      var flag =0;
	      ByCountry.forEach(function(country){
      		    if (country.key == d.properties.name){
          			value = country.means[criteria].toPrecision(3);
          			flag = 1;
          		}
	      })
	      if (flag==0) {
	      	value = "No data available";
	      	rank = "No data available";
	      }
	      var mouse = d3.mouse(svg.node())
	        .map( function(d) { return parseInt(d); } );
	      tooltip.classed("hidden", false)
	        .attr("style", "left:"+(mouse[0]+offsetL)+"px;top:"+(mouse[1]+offsetT)+"px")
	        .html("<em>" + name + "</em> </br> Value :" + value + "</br> Rank : " + rank);
	    }

	    function selected() {
	      d3.select('.selected').classed('selected', false);
	      d3.select(this).classed('selected', true);
	    }


	    function zoomed() {
	      var t = d3.event.translate;
	      s = d3.event.scale; 
	      var h = 0;

	      t[0] = Math.min(
	        (width/height)  * (s - 1), 
	        Math.max( width * (1 - s), t[0] )
	      );

	      t[1] = Math.min(
	        h * (s - 1) + h * s, 
	        Math.max(height  * (1 - s) - h * s, t[1])
	      );

	      zoom.translate(t);
	      if(s === 1 && mouseClicked) {
	        rotateMap(d3.mouse(this)[0])
	        return;
	      }

	      g.attr("transform", "translate(" + t + ")scale(" + s + ")");

	      //adjust the stroke width based on zoom level
	      d3.selectAll(".boundary")
	        .style("stroke-width", 1 / s);
	  }
  // End of Data processing
}});
  </script>
</body>
</html>
